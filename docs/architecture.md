# Pet App V3 æ¶æ„è®¾è®¡æ–‡æ¡£

## ğŸ—ï¸ æ•´ä½“æ¶æ„æ¦‚è§ˆ

Pet App V3 é‡‡ç”¨"ä¸‡ç‰©çš†æ’ä»¶"çš„æ¨¡å—åŒ–æ¶æ„è®¾è®¡ï¼Œé€šè¿‡æ’ä»¶ç³»ç»Ÿå®ç°é«˜åº¦å¯æ‰©å±•çš„åº”ç”¨ç”Ÿæ€ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Pet App V3 æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ  é¦–é¡µ    ğŸ¨ åˆ›æ„å·¥åŠ   ğŸ“± åº”ç”¨ç®¡ç†   ğŸ¾ æ¡Œå®    âš™ï¸ è®¾ç½®    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ’ä»¶è¿è¡Œæ—¶ç¯å¢ƒ                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    å¹³å°é€‚é…å±‚                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Flutter Framework & Dart VM                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           ğŸ“± Mobile    ğŸ–¥ï¸ Desktop    ğŸŒ Web                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¯ æ ¸å¿ƒè®¾è®¡ç†å¿µ

### 1. ä¸‡ç‰©çš†æ’ä»¶ (Everything as Plugin)
```
ğŸ”Œ ç³»ç»Ÿçº§æ’ä»¶: ä¸»é¢˜ã€è®¾ç½®ã€æ–‡ä»¶ç®¡ç†
ğŸ® åŠŸèƒ½çº§æ’ä»¶: æ¡Œå® ã€å°æ¸¸æˆã€å·¥å…·
ğŸ¨ UIçº§æ’ä»¶: ç»„ä»¶ã€å¸ƒå±€ã€åŠ¨ç”»
ğŸ”§ å¼€å‘çº§æ’ä»¶: ä»£ç ç¼–è¾‘å™¨ã€è°ƒè¯•å™¨
```

### 2. ä¸‰ç«¯ç‰¹å¾åŒ– (Platform-Specific UX)
```
ğŸ“± Mobile: è§¦æ‘¸ä¼˜åŒ–ã€åº•éƒ¨å¯¼èˆªã€æ‰‹åŠ¿äº¤äº’
ğŸ–¥ï¸ Desktop: é¼ æ ‡é”®ç›˜ã€ä¾§è¾¹æ ã€å¤šçª—å£
ğŸŒ Web: æµè§ˆå™¨ç‰¹æ€§ã€URLè·¯ç”±ã€å“åº”å¼
```

### 3. æ¨¡å—åŒ–è§£è€¦ (Modular Decoupling)
```
ğŸ”— æ¥å£é©±åŠ¨: æ¨¡å—é—´åªé€šè¿‡æ¥å£é€šä¿¡
ğŸ“¦ ç‹¬ç«‹æ‰“åŒ…: æ¯ä¸ªæ¨¡å—å¯ç‹¬ç«‹å¼€å‘éƒ¨ç½²
ğŸ”„ çƒ­æ’æ‹”: æ”¯æŒè¿è¡Œæ—¶åŠ è½½å¸è½½æ¨¡å—
```

## ğŸ›ï¸ åˆ†å±‚æ¶æ„è®¾è®¡

### Layer 1: å¹³å°å±‚ (Platform Layer)
```dart
// å¹³å°æŠ½è±¡æ¥å£
abstract class PlatformService {
  Future<void> initialize();
  bool get isSupported;
  Map<String, dynamic> get capabilities;
}

// å…·ä½“å¹³å°å®ç°
class MobilePlatformService extends PlatformService { ... }
class DesktopPlatformService extends PlatformService { ... }
class WebPlatformService extends PlatformService { ... }
```

### Layer 2: æ ¸å¿ƒå±‚ (Core Layer)
```dart
// æ’ä»¶ç³»ç»Ÿæ ¸å¿ƒ
class PluginSystem {
  static final PluginRegistry registry = PluginRegistry();
  static final PluginLoader loader = PluginLoader();
  static final PluginMessenger messenger = PluginMessenger();
  static final ResourceMonitor monitor = ResourceMonitor();
}

// åº”ç”¨æ ¸å¿ƒæœåŠ¡
class CoreServices {
  static final NavigationService navigation = NavigationService();
  static final ThemeService theme = ThemeService();
  static final ConfigService config = ConfigService();
  static final EventBus eventBus = EventBus();
}
```

### Layer 3: ä¸šåŠ¡å±‚ (Business Layer)
```dart
// äº”å¤§æ ¸å¿ƒæ¨¡å—
abstract class CoreModule {
  String get id;
  String get name;
  Widget buildUI();
  Future<void> initialize();
}

class HomeModule extends CoreModule { ... }
class CreativeWorkshopModule extends CoreModule { ... }
class AppManagerModule extends CoreModule { ... }
class DesktopPetModule extends CoreModule { ... }
class SettingsModule extends CoreModule { ... }
```

### Layer 4: è¡¨ç°å±‚ (Presentation Layer)
```dart
// å¹³å°é€‚é…çš„UIå±‚
class AdaptiveUI {
  static Widget build(BuildContext context, Widget child) {
    final adapter = PlatformAdaptationManager.current;
    return adapter.buildLayout(child);
  }
}
```

## ğŸ”Œ æ’ä»¶ç³»ç»Ÿæ¶æ„

### æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æœªåŠ è½½     â”‚â”€â”€â”€â–¶â”‚   å·²åŠ è½½     â”‚â”€â”€â”€â–¶â”‚  å·²åˆå§‹åŒ–    â”‚
â”‚  Unloaded   â”‚    â”‚   Loaded    â”‚    â”‚ Initialized â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å·²é”€æ¯     â”‚â—€â”€â”€â”€â”‚   å·²åœæ­¢     â”‚â—€â”€â”€â”€â”‚   å·²å¯åŠ¨     â”‚
â”‚  Disposed   â”‚    â”‚   Stopped   â”‚    â”‚   Started   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
                                              â–¼
                                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                      â”‚   å·²æš‚åœ     â”‚
                                      â”‚   Paused    â”‚
                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ’ä»¶æ³¨å†Œä¸­å¿ƒ
```dart
class PluginRegistry {
  final Map<String, Plugin> _plugins = {};
  final Map<String, PluginMetadata> _metadata = {};
  final Map<String, PluginState> _states = {};
  
  // æ’ä»¶æ³¨å†Œ
  Future<void> register(Plugin plugin) async {
    _validatePlugin(plugin);
    _plugins[plugin.id] = plugin;
    _metadata[plugin.id] = PluginMetadata.from(plugin);
    _states[plugin.id] = PluginState.loaded;
    
    await _resolveDependencies(plugin);
    _notifyPluginRegistered(plugin);
  }
  
  // æ’ä»¶æŸ¥æ‰¾
  Plugin? get(String id) => _plugins[id];
  
  // æŒ‰ç±»åˆ«æŸ¥æ‰¾
  List<Plugin> getByCategory(PluginCategory category) {
    return _plugins.values
        .where((p) => p.category == category)
        .toList();
  }
  
  // ä¾èµ–è§£æ
  Future<void> _resolveDependencies(Plugin plugin) async {
    for (final dep in plugin.dependencies) {
      if (!_plugins.containsKey(dep.pluginId)) {
        if (!dep.optional) {
          throw PluginDependencyException(plugin.id, dep.pluginId);
        }
      }
    }
  }
}
```

### æ’ä»¶é€šä¿¡æœºåˆ¶
```dart
// æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿ
class PluginMessenger {
  static final Map<String, StreamController> _channels = {};
  
  // å‘é€æ¶ˆæ¯
  static Future<T?> sendMessage<T>(
    String targetPluginId,
    String action,
    Map<String, dynamic> data,
  ) async {
    final target = PluginRegistry.get(targetPluginId);
    if (target == null) {
      throw PluginNotFoundException(targetPluginId);
    }
    
    return await target.handleMessage(action, data) as T?;
  }
  
  // è®¢é˜…æ¶ˆæ¯
  static Stream<PluginMessage> subscribe(String pluginId) {
    _channels.putIfAbsent(
      pluginId, 
      () => StreamController<PluginMessage>.broadcast(),
    );
    return _channels[pluginId]!.stream;
  }
  
  // å¹¿æ’­æ¶ˆæ¯
  static Future<void> broadcast(PluginMessage message) async {
    for (final controller in _channels.values) {
      controller.add(message);
    }
  }
}

// äº‹ä»¶æ€»çº¿
class EventBus {
  static final StreamController<Event> _controller = 
      StreamController<Event>.broadcast();
  
  static void emit(String type, dynamic data) {
    _controller.add(Event(type: type, data: data));
  }
  
  static Stream<Event> on(String type) {
    return _controller.stream.where((event) => event.type == type);
  }
}
```

## ğŸ¨ åˆ›æ„å·¥åŠæ¶æ„

### æ’ä»¶å¼€å‘ç¯å¢ƒ
```dart
class CreativeWorkshop {
  final PluginProjectManager projectManager;
  final CodeEditor codeEditor;
  final PluginBuilder builder;
  final PluginTester tester;
  final PluginPublisher publisher;
  
  // åˆ›å»ºæ–°æ’ä»¶é¡¹ç›®
  Future<PluginProject> createProject(PluginTemplate template) async {
    final project = await projectManager.create(template);
    await _setupDevelopmentEnvironment(project);
    return project;
  }
  
  // æ„å»ºæ’ä»¶
  Future<PluginPackage> buildPlugin(PluginProject project) async {
    await _validateProject(project);
    final package = await builder.build(project);
    await _runTests(package);
    return package;
  }
  
  // å‘å¸ƒæ’ä»¶
  Future<void> publishPlugin(PluginPackage package) async {
    await _validatePackage(package);
    await publisher.publish(package);
    _notifyPublished(package);
  }
}
```

### Ming CLIé›†æˆ
```dart
class MingCliIntegration {
  static Future<PluginProject> createFromTemplate(
    String templateName,
    Map<String, dynamic> config,
  ) async {
    // è°ƒç”¨Ming CLIç”Ÿæˆé¡¹ç›®
    final result = await Process.run('ming', [
      'template',
      'create',
      '--name=${config['name']}',
      '--type=${config['type']}',
      '--complexity=${config['complexity']}',
      '--output=${config['output']}',
      '--no-wizard',
    ]);
    
    if (result.exitCode != 0) {
      throw MingCliException(result.stderr);
    }
    
    return PluginProject.fromPath(config['output']);
  }
}
```

## ğŸ“± åº”ç”¨ç®¡ç†æ¶æ„

### æ’ä»¶è¿è¡Œæ—¶ç¯å¢ƒ
```dart
class PluginRuntime {
  final Map<String, PluginInstance> _instances = {};
  final ResourceMonitor _monitor = ResourceMonitor();
  final SecurityManager _security = SecurityManager();
  
  // å¯åŠ¨æ’ä»¶å®ä¾‹
  Future<PluginInstance> startPlugin(String pluginId) async {
    final plugin = PluginRegistry.get(pluginId);
    if (plugin == null) {
      throw PluginNotFoundException(pluginId);
    }
    
    // æƒé™æ£€æŸ¥
    await _security.checkPermissions(plugin);
    
    // åˆ›å»ºéš”ç¦»çš„è¿è¡Œç¯å¢ƒ
    final instance = PluginInstance(plugin);
    await instance.initialize();
    
    // èµ„æºç›‘æ§
    _monitor.startMonitoring(instance);
    
    _instances[pluginId] = instance;
    return instance;
  }
  
  // åœæ­¢æ’ä»¶å®ä¾‹
  Future<void> stopPlugin(String pluginId) async {
    final instance = _instances[pluginId];
    if (instance != null) {
      _monitor.stopMonitoring(instance);
      await instance.dispose();
      _instances.remove(pluginId);
    }
  }
}
```

### æ–‡ä»¶ç³»ç»Ÿç®¡ç†
```dart
class PluginFileSystem {
  final String _basePath;
  final Map<String, String> _pluginPaths = {};
  
  // ä¸ºæ’ä»¶åˆ†é…ç‹¬ç«‹çš„æ–‡ä»¶ç©ºé—´
  String getPluginPath(String pluginId) {
    return _pluginPaths.putIfAbsent(
      pluginId,
      () => path.join(_basePath, 'plugins', pluginId),
    );
  }
  
  // æ–‡ä»¶è®¿é—®æƒé™æ§åˆ¶
  Future<bool> checkFileAccess(String pluginId, String filePath) async {
    final pluginPath = getPluginPath(pluginId);
    return filePath.startsWith(pluginPath);
  }
}
```

## ğŸ”’ å®‰å…¨æ¶æ„

### æƒé™ç®¡ç†ç³»ç»Ÿ
```dart
class SecurityManager {
  final Map<String, Set<Permission>> _grantedPermissions = {};
  
  // æ£€æŸ¥æ’ä»¶æƒé™
  Future<void> checkPermissions(Plugin plugin) async {
    for (final permission in plugin.requiredPermissions) {
      if (!await _hasPermission(plugin.id, permission)) {
        final granted = await _requestPermission(plugin.id, permission);
        if (!granted) {
          throw PermissionDeniedException(plugin.id, permission);
        }
      }
    }
  }
  
  // æƒé™æ²™ç®±
  Future<T> executeWithPermissions<T>(
    String pluginId,
    List<Permission> permissions,
    Future<T> Function() operation,
  ) async {
    final context = SecurityContext(pluginId, permissions);
    return await SecurityZone.run(context, operation);
  }
}
```

### èµ„æºé™åˆ¶
```dart
class ResourceMonitor {
  final Map<String, ResourceUsage> _usage = {};
  
  // ç›‘æ§æ’ä»¶èµ„æºä½¿ç”¨
  void startMonitoring(PluginInstance instance) {
    final timer = Timer.periodic(Duration(seconds: 1), (timer) {
      final usage = _measureUsage(instance);
      _usage[instance.pluginId] = usage;
      
      if (_isExceedingLimits(usage)) {
        _handleResourceViolation(instance);
      }
    });
    
    instance.onDispose(() => timer.cancel());
  }
  
  // å¤„ç†èµ„æºè¿è§„
  void _handleResourceViolation(PluginInstance instance) {
    // è­¦å‘Š -> é™åˆ¶ -> ç»ˆæ­¢
    final violations = _getViolationCount(instance.pluginId);
    
    if (violations > 3) {
      instance.terminate();
    } else if (violations > 1) {
      instance.throttle();
    } else {
      instance.warn();
    }
  }
}
```

## ğŸ¨ UIæ¶æ„è®¾è®¡

### å“åº”å¼è®¾è®¡ç³»ç»Ÿ
```dart
class ResponsiveDesignSystem {
  static const breakpoints = {
    'mobile': 600.0,
    'tablet': 900.0,
    'desktop': 1200.0,
    'ultrawide': 1600.0,
  };
  
  static Widget adaptive({
    required Widget mobile,
    Widget? tablet,
    Widget? desktop,
    Widget? ultrawide,
  }) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final width = constraints.maxWidth;
        
        if (width >= breakpoints['ultrawide']!) {
          return ultrawide ?? desktop ?? tablet ?? mobile;
        } else if (width >= breakpoints['desktop']!) {
          return desktop ?? tablet ?? mobile;
        } else if (width >= breakpoints['tablet']!) {
          return tablet ?? mobile;
        } else {
          return mobile;
        }
      },
    );
  }
}
```

### ä¸»é¢˜ç³»ç»Ÿ
```dart
class ThemeSystem {
  static final Map<String, ThemeData> _themes = {};
  static final ValueNotifier<String> _currentTheme = ValueNotifier('default');
  
  // æ³¨å†Œä¸»é¢˜
  static void registerTheme(String id, ThemeData theme) {
    _themes[id] = theme;
  }
  
  // åˆ‡æ¢ä¸»é¢˜
  static void switchTheme(String themeId) {
    if (_themes.containsKey(themeId)) {
      _currentTheme.value = themeId;
    }
  }
  
  // è·å–å½“å‰ä¸»é¢˜
  static ThemeData get currentTheme {
    return _themes[_currentTheme.value] ?? ThemeData();
  }
}
```

## ğŸ“Š æ€§èƒ½æ¶æ„

### æ‡’åŠ è½½ç³»ç»Ÿ
```dart
class LazyLoadManager {
  final Map<String, Future<dynamic>> _loadingCache = {};
  
  // æ‡’åŠ è½½æ’ä»¶
  Future<Plugin> loadPlugin(String pluginId) async {
    return _loadingCache.putIfAbsent(
      pluginId,
      () => _doLoadPlugin(pluginId),
    ) as Future<Plugin>;
  }
  
  // é¢„åŠ è½½ç­–ç•¥
  Future<void> preloadCriticalPlugins() async {
    final criticalPlugins = ['theme_system', 'navigation', 'settings'];
    await Future.wait(
      criticalPlugins.map((id) => loadPlugin(id)),
    );
  }
}
```

### ç¼“å­˜ç³»ç»Ÿ
```dart
class CacheManager {
  final Map<String, CacheEntry> _cache = {};
  final int _maxSize;
  final Duration _ttl;
  
  // ç¼“å­˜æ•°æ®
  void put(String key, dynamic data) {
    _cache[key] = CacheEntry(
      data: data,
      timestamp: DateTime.now(),
    );
    
    _evictIfNeeded();
  }
  
  // è·å–ç¼“å­˜
  T? get<T>(String key) {
    final entry = _cache[key];
    if (entry == null) return null;
    
    if (DateTime.now().difference(entry.timestamp) > _ttl) {
      _cache.remove(key);
      return null;
    }
    
    return entry.data as T?;
  }
}
```

## ğŸ”„ æ•°æ®æµæ¶æ„

### çŠ¶æ€ç®¡ç†
```dart
// ä½¿ç”¨Riverpodè¿›è¡ŒçŠ¶æ€ç®¡ç†
final pluginStateProvider = StateNotifierProvider.family<
    PluginStateNotifier, 
    PluginState, 
    String
>((ref, pluginId) {
  return PluginStateNotifier(pluginId);
});

class PluginStateNotifier extends StateNotifier<PluginState> {
  final String pluginId;
  
  PluginStateNotifier(this.pluginId) : super(PluginState.unloaded);
  
  Future<void> loadPlugin() async {
    state = PluginState.loading;
    try {
      await PluginRegistry.load(pluginId);
      state = PluginState.loaded;
    } catch (e) {
      state = PluginState.error;
    }
  }
}
```

### æ•°æ®æŒä¹…åŒ–
```dart
class DataPersistence {
  static final Map<String, StorageAdapter> _adapters = {};
  
  // æ³¨å†Œå­˜å‚¨é€‚é…å™¨
  static void registerAdapter(String type, StorageAdapter adapter) {
    _adapters[type] = adapter;
  }
  
  // ä¿å­˜æ•°æ®
  static Future<void> save(String key, dynamic data, {String? type}) async {
    final adapter = _adapters[type ?? 'default'];
    if (adapter != null) {
      await adapter.save(key, data);
    }
  }
  
  // åŠ è½½æ•°æ®
  static Future<T?> load<T>(String key, {String? type}) async {
    final adapter = _adapters[type ?? 'default'];
    if (adapter != null) {
      return await adapter.load<T>(key);
    }
    return null;
  }
}
```

## ğŸ“‹ æ¶æ„åŸåˆ™

### 1. å•ä¸€èŒè´£åŸåˆ™ (SRP)
æ¯ä¸ªæ¨¡å—ã€ç±»å’Œå‡½æ•°éƒ½åº”è¯¥æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªèŒè´£ã€‚

### 2. å¼€é—­åŸåˆ™ (OCP)
ç³»ç»Ÿåº”è¯¥å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ã€‚é€šè¿‡æ’ä»¶ç³»ç»Ÿå®ç°åŠŸèƒ½æ‰©å±•ã€‚

### 3. ä¾èµ–å€’ç½®åŸåˆ™ (DIP)
é«˜å±‚æ¨¡å—ä¸åº”è¯¥ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½åº”è¯¥ä¾èµ–æŠ½è±¡ã€‚

### 4. æ¥å£éš”ç¦»åŸåˆ™ (ISP)
å®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£ã€‚

### 5. æœ€å°æƒé™åŸåˆ™
æ’ä»¶åªèƒ½è®¿é—®å…¶å£°æ˜çš„æƒé™èŒƒå›´å†…çš„èµ„æºã€‚

---

æ›´å¤šè¯¦ç»†ä¿¡æ¯è¯·å‚è€ƒï¼š
- [å¼€å‘æŒ‡å—](./development_guide.md)
- [æ’ä»¶APIæ–‡æ¡£](./plugin_api.md)
- [å¹³å°ç‰¹å¾åŒ–æŒ‡å—](./platform_guide.md)
